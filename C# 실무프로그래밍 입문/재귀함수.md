## 재귀함수(recursive function)

- 이미 해결한 작은 문제에 어부바~해서 더 큰 문제를 해결하는 방법
- 함수 A가 매개변수만 바꾸어 다시 함수 A를 호출하는 방법으로 구현 



### 재귀함수의 구성요소

- 종료조건(ending condition, base case)
  - 더 이상 재귀 함수를 호출하기 않고 값을 반환하는 조건
  - 매우 간단히 함수의 반환 값을 찾을 수 있는 경우
  - 이것이 없으면 함수를 무한히 재귀적으로 호출
- 재귀적 함수 호출
  - 종료조건이 아닌 경우
  - 함수의 인자를 바꿔 스스로를 다시 호출
  - 이 때, 함수의 인자는 현재 문자보다 작은 문제를 대표해야함
  - 즉, 동일한 동작을 보다 작은 문제에 적용

~~~c#
static unit SunRecursive(uint num)
{
	if (num == 0)
	{
		return 0; // 종료조건
	}
	else {
		return SunRecursive(num -1 ) + num; // 재귀호출
	}
}
~~~

종료조건이 없는 경우 무한 함수 호출에 빠져버린다 **까먹지말자**



#### 반복문과의 비교

- 매우 단순한 문제는 당연히 반복문이 쉬움

![스크린샷 2020-12-17 오후 6 07 36](https://user-images.githubusercontent.com/47776915/102466746-c8036280-4092-11eb-9996-fadfb48b9d2b.png)

- 모든 재귀함수는 반복문으로 해결 가능
- 그러나 복잡한 문제일수록 재귀 함수가 더 편함
  - 이진검색
  - 트리구조
  - 퀵정렬
  - 하노이의 탑
  - 어떤 폴더 아래에 있는 모든 파일 목록 구하기



#### 피보나치 수열로 이해하는 재귀함수

- 제 0항은0, 제1항은 1이며, 그 뒤에 모든항은 바로 앞 두 항의 합인 수열

`0 1 1 2 3  5 8 13 21 34 55 ....`

- 수학적 정의 ![스크린샷 2020-12-17 오후 6 24 52](https://user-images.githubusercontent.com/47776915/102468657-2a5d6280-4095-11eb-8163-000bbefbdb17.png)

  

#### 피보나치 수

![스크린샷 2020-12-17 오후 6 27 59](https://user-images.githubusercontent.com/47776915/102469013-9a6be880-4095-11eb-9198-122121bbb442.png)

#### 폴더의 목록을 가져오는 함수(의사 코드)

![스크린샷 2020-12-17 오후 6 37 13](https://user-images.githubusercontent.com/47776915/102470212-0a2ea300-4097-11eb-8375-2eb9116ed369.png)



#### 재귀함수의 장점

- 개념적으로 매우 훌륭함
- 증명이 가능하기에 두 발 뻗고 잘 수 있다



#### 재귀함수의 단점

- 효율성이 떨어진다
- 함수 호출 깊이에는 제한이 있음 (스택 오버플로우)

