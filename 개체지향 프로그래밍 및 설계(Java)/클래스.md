## 클래스

#### OOP에서의 클래스

- 새로운 개체를 만들 때 사용하는 명세서
- 개체는 반드시 클래스로부터 만들어야함
- 명세서에 담긴 내용
  - 속성(상태)
  - 동작
  - 등(뒤에 좀 더 나옴)



##### Java와 C# 모두 동적할당을 한다



#### 인스턴스(instance)

- 개체를 부르는 또 다른 표현
- 인스턴스의 뜻은 사례
- `어떤 클래스에 속하는 개체의 한 예`라는 의미

~~~java
// 개체를 인스턴스화 한다
Human adam = new Human();
Human fiona = new Human();
~~~



#### 개체 멤버 변수에 접근하기 



##### 참조형 vs 값형

- 자바는 기본자료형 제외하면 모드 포인형 (Java에서는 참조형과 값형 변수 선언이 똑같아 보여 헷갈릴 수 있음ㄴ)

- 자바에 포인터가 없가는 건 거짓말

  - `자바에서는 모든것이 포인터다!` 라고 해도 될 정도(예외: 기본 자료형)
  - 포인터 연산이 불가능 할 뿐

  

> C는 개체를 포인터 혹은 값으로 둘 다 전달 가능!
>
> Java는 포인터로만 전달 가능



##### 개체 생성시 멤버 데이터의 초기화

![스크린샷 2021-01-07 오전 11 06 02](https://user-images.githubusercontent.com/47776915/103842068-568a6300-50d8-11eb-84d5-0427688cc899.png)

- Java는 **0에 준하는 값**으로 초기화 해줌

  - int는 0
  - float는 0.0
  - 참조형은 null

  

#### Java에는 free()가 없다

- Java는 가비지 컬렉션(garbage collection, CG)가능을 지원
  - 더이상 사용되지 않는 개체(즉, 힙메모리)
  - 프로그랴머가 직접 메모리를 해제하지 않는다
  - C#도 가비지 컬렉션을 지원
- 매니지드(managed) 언어는 보통 자동으로 메모리를 관리해줌



> 가바지 컬렉터가 메모리를 수집하는 시점을 알 수 없음
>
> 모든 개체의 사용여부를 판단하는게 그리 빠른 연산이 아님

이러한 이유로 자원이 한정적인 시스템에는 적합하지 않음

자동메모리 관리 하에서 발생하는 메모리 누수도 존재



### 생성자

~~~java
public <클래스명>(<매개변수 목록>) {
	...
}

public Human(String name, int age, Sex sex) {
	this.name = name;
	this.age = age;
	this.sex = sex;
}

~~~

- 생성자라는 특별한 메서드가 이런 일을 담당

  - 개체 생성시에 자동으로 호출되는 특수한 함수
  - 번환형 없음 (void가 아님!)
  - 함수명: 클래스명과 동일

- 오버로딩도 가능! (매개변수를 다르게 할수있음)

  ![스크린샷 2021-01-07 오전 11 30 13](https://user-images.githubusercontent.com/47776915/103843743-b7676a80-50db-11eb-8ff1-d746f9834a08.png)

##### 생성자 오버로딩에서 코드 중복을 피하는 방법

- 매개변수 수가 적은 생성자에서 매개변수 수가 많은 생성자를 호출!

- `this() `를 이용하면 다른 생성자를 호출할 수 있음

  ~~~java
  public Human(String name, Sex sex) {
  	this(name, sex == Sex.Male ? 1: 5, sex);
  }
  ~~~

##### 프로그래머가 생성자를 제공하면 기본 생성자(생성자를 하나도 안 만들 경우 자동으로 생김)는 생기지 않음



##### 생성자로 초기화해야 하는 이유?

1. `개체의 상태는 개체생성과 동시에 유효하다`

2. 사용자의 실수를 방지
3. 나중에 멤버변수가 추가 될 때 기존의 초기화코드를 업데이트 안하면?





### < 접근제어자 >

- 어떤 외부자들이 개체속에 접근할 수 있는지 정의
- 접근제어자를 안 붙일 경우 기본(default) 접근 권한, 같은 패키지 안에 있는 클래스 끼리 서로 접근가능

#### - public(누구나 접근 가능)

- 멤버변수와 멤버함수 선언 시 앞에 붙는 접근 제어자
- 외부(누구나)에서 클래스 내부에 담김 상태/ 동작에 접근, 수정 하는 것을 허용
  - 여기서 외부는 다른 패키지를 의미

#### - protected (자식들만 접근 가능)

#### - 생략할 경우: 같은 패지지에 속한 클래스들만 접근 가능(default 혹은 package 접근제어자라 부름)

#### - private: 외부 접근 금지

- 외부자들은 접근 할 수 없음
- 클래스 내부에서만 접근 가능함
- 클래스의 경우 내포(nested) 클래스에 한 해 붙일 수 있음

![스크린샷 2021-01-15 오후 4 09 56](https://user-images.githubusercontent.com/47776915/104693224-a1495200-574c-11eb-8df5-c473178f2d60.png)